CẤU TRÚC DỮ LIỆU
* Truyền thống 
	+ int, float, double, char, boolean
	+ array, linked list, tree, stack, queue
	--- Hạn chế ---
	VD: Array --> fixed size
	
* JAVA custom
	- Collections --> danh sách, tập hợp
	  + là một interface
	  + list, set, map
	     . list: dựa trên cấu trúc dữ liệu của mảng và danh sách liên kết 
	           : thêm các functions, tối ưu để có thể dễ dàng thêm sửa xóa...
	           : interface/implementation classes dựa trên mảng, danh sách liên kết
	           
	     . set : dựa trên idea của danh sách liên kết 
	           : lưu những phần tử không trùng nhau
	           
	     . map : lưu trữ theo cơ thế key, value
	           : hỗ trợ tìm kiếm nhanh (fast searching) theo key
	           
	           VD: list --> tìm kiếm phần tử theo giá trị 
	                    --> cần duyệt O(n), ai bằng thì lấy ra
	               map  --> tìm kiếm phần tử theo key
	                    --> cần get(key) --> O(1)
	                    --> put (key, value) --> key --> hashing --> dãy số trong memory
	           
=================================

LIST
* ArrayList
  Object[] elementData;
  int size;
  
  + new ArrayList();
    --> elementData = {};
    
  + add
    --> 
    public boolean add(E e) {
        modCount++;
        add(e, elementData, size);
        return true;
    }
    
    private void add(E e, Object[] elementData, int s) {
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1;
    }
    
    private Object[] grow() {
        return grow(size + 1);
    }
    
    private Object[] grow(int minCapacity) {
        int oldCapacity = elementData.length;
        if (oldCapacity > 0 || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            int newCapacity = ArraysSupport.newLength(oldCapacity,
                    minCapacity - oldCapacity, /* minimum growth */
                    oldCapacity >> 1           /* preferred growth */);
            return elementData = Arrays.copyOf(elementData, newCapacity);
        } else {
            return elementData = new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];
        }
    }
    
    ***
    --> Lần đầu tiên add vào newCapacity = 10 (tức length của array elementData = 10)
        [null, null, null, null, null, null, null, null, null, null]
        ↓
        elementData[0] = "Hello";
        ['Hello', null, null, null, null, null, null, null, null, null]
        // size = 1
        ↓
        elementData[1] = "Welcome";
        ['Hello', 'Welcome', null, null, null, null, null, null, null, null]
        // size = 2
        ↓
        "size" --> số lượng phần tử thực sự chứa trong elementData
        
        Khi duyệt --> truy cập ArrayList được phép từ [0, size)
        
        P/s: oldCapacity >> 1 
             a >> b (a dịch phải b đơn vị) => Công thức: a/2^b
             
        KẾT LUẬN
        + Lần đầu mặc định capacity = 10
        + Mỗi lần tiếp theo capacity += capacity/2
        
        TUY NHIÊN 
        Khi mình biết trước số lượng phần tử tối đa lưu trong ArrayList
        --> nên điền capacity vào lúc tạo ArrayList
        --> để tạo ra 1 mảng elementData duy nhất
             
================================

GENERIC TYPE 
+ Là khái niệm xuất hiện từ JAVA 1.5 
+ Là KDL đại diện cho bất kỳ KDL đối tượng nào 
+ Hỗ trợ bắt lỗi tại compile
--> Phải khai báo và sử dụng
--> Quy tắc đặt tên: 1 chữ cái và in hoa 
--> Giới hạn trên với từ khóa extends

GENERIC METHOD
+ Là method có KDL truyền vào là Generic Type

GENERIC CLASS, METHOD
+ Là class, interface có tham số truyền vào là generic type

GENERIC WILDCARD
- Khi có generic class, interface, method có yêu cầu tham số truyền vào là GENERIC TYPE
 + Lúc mình gọi chưa biết truyền KDL gì vào thì cso thể sử dụng wildcard làm KDL tạm thời
 + Cũng có thể khai báo wildcard để người dùng gọi xử lý
 
 Sử dụng đề truyền tham số hơn là khai báo
 
 --> Không thể khai báo trong generic class, interface
 --> Giới hạn dưới với từ khóa super










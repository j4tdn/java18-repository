1. Tính chất thừa kế là gì, cho ví dụ code minh họa

	--> khi các class mình code có chung thuộc tính/phương thức, trùng lặp code
		--> sẽ tạo ra 1 class cha chứa những thuộc tính/phương thức chung đó
		--> sau đó một class con sẽ kế thừa từ cha, muốn extends/override thì tạo thêm ở lớp con
		
	Ví dụ:
		+ Thừa kế thuộc tính
			class Book: id, name, publisher
			class ClassicalBook extends Book
				status
			class Referencebook extends Book
				tax
			
		+ Thừa kế phương thức
			interface Shape
				void calS();
			Class Rectangle implement Shape {
				@Override
				public void cals() {
				}
			}
			
			class Father {
				String getSport() {
					return "badminton, volleyball";
				}
			}
			
			class Son extends Father {
				
			}
			

2. KDL cha có thể là ai
	--> class, abstract class, interface

3. Phân biệt class/abstract class/interface

	+ class: chứa thuộc tính và phương thức bình thường
	+ abstract class: chứa thuộc tính và phuong thức trừu tượng
	
	--> cha là [abstract]class thì class con chỉ kế thừa duy nhất được 1 [abstract]class
	
	+ interface: chứa thuộc tính và phương thức trừu tượng
		. thuộc tính trong interface bắt buộc
			+ phải khởi tại giá trị --> vì không thể override trong lớp con
			+ mặc định là static
			+ hiếm khi tạo biến/thuộc tính trong interface
			
	--> cha là interface thì class con chỉ kế thừa duy nhất được 1 hoặc nhiều interface
	
	+ interface mở rộng từ JAVA08 đếm hiện tại
		--> có thể chứa
		. phương thức trừu tượng
		. phương thức bình thường
			private/default/static return_type method_name(...) {
				// body
			}
		. Vì sao từ JAVA08 interface cho phép chứa hàm bình thường
		. Lúc này interface sẽ có chức năng giống với abstract class
		--> Sao ko dùng abstract class luôn? lợi ích gì?
		
		--> Interface --> 1/N hàm trừu tượng
			+ có 2 cách để override hàm trừu tượng
				1. Tạo class con implement từ interface
					--> override abstract method
				2. New trực tiếp interface --> anonymous class
					--> override abstract method
				-new-> khi interface có 1 hàm trừu tượng
					--> functional interface @FunctionalInterface
					--> Để tạo đối tượng/thể hiện/giá trị cho biến kiểu functional interface
					--> thay vì dùng 2 cách phía trên thì sử dụng anonymous function (lambda expression)
	
	
	. phương thức bình thường: có body	
	. phương thức trừu tượng: không có body
	
--> n KDL con có thể kế thừa từ 1 KDL cha

4. 1 KDL con có thể kế thừa từ 1/n KDL cha
	con: class/interface/abstract class
	cha: class/interface/abstract class
	
	Khi KDL CON là CLASS
		--> chỉ có thể kế thừa(extedns) duy nhất từ 1 CLASS cha
		
			Vì nếu như 1 class con kế thừa từ nhiều class cha
			Trong trường hợp các class cha có chung hàm(khai báo) và các
			phương thức lại không bắt buộc override trong class --> con kế thừa
			dùng mặc định các hàm chung từ class cha
		
			--> con gọi phương thức chung đó --> không biết gọi ai
			--> error first --> không cho extends từ nhiều class cha
		
		--> có thể kế thừa(thực thi)(implements) từ N interface cha
	
	KEY: 
		--> phương thức trong CLASS cha --> không bắt buộc override trong CLASS con
		--> phương thức trong INTERFACE cha --> bắt buộc override trong CLASS con
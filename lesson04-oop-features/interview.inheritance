    // private: dùng trong class
	// public
	// default --> nếu [abstract] class --> sử dụng trong package hiện tại
	//         --> nếu interface --> giống như public
	// protected
	// --> sử dụng trong package hiện tại
	// --> sử dụng khác package nếu nó là con của class hiện tại
	
Câu 1. Tính chất thừa kế là gì, cho ví dụ, code minh họa
	
	--> Khi các class mình muốn dùng có những phương thức/thuộc tính trùng nhau. 
Thay vì tạo ra các class giống nhau.
---> Sẽ tạo ra 1 class cha chứa những thuộc tính/phương thức chung đó
---> Sau đó một class con sẽ kế thừa từ cha, muốn extends/override thì tạo thêm
ở lớp con
	Ví dụ: 
	+ Thừa kế thuộc tính
		class Book: id, name, pulisher
		class ClassicalBook extends Book
			status
		class ReferenceBook extends Book
			tax
			
			
	+ Thừa kế/định nghĩa phương thức
		interface Shape
			void calS ();
		class Rectangle implement Shape {
		@Override
		public void calS () {
		}
	}
	
		class Father {
			String getSport (){
			return "badminton, volleyball"
			}
		}
		
		class Son extends Father {
			
		}
		
Câu 2. KDL cha có thể là ai??
	--> class, abstract class, interface
	
Câu 3: Phân biệt class, abstract class, interface

--> class: chỉ chứa thuộc tính và phương thức bình thường
--> abstract class: chứa thuộc tính và phương thức bình thường và trừu tượng
	--> cha là [abstract] class thì class con chủ kế
	thừa duy nhất được 1 [abstract] class
	
--> interface: chứa thuộc tính và phương thức trừu tượng
	--> cha là interface thì class con chủ kế
	thừa từ 1 hoặc nhiều interface
	
	. Phương thức bình thường: là phương thức có body
	. Phương thức trừu tượng: là phương thức không có body
	--> Không có body nhưng tại sao vẫn tạo ra???
	
	. Thuộc tính trong interface bắt buộc
		+ Phải khởi tạo giá trị --> vì không thể override trong lớp con
		+ Mặc định là static
		+ Hiếm khi tạo biến/thuộc tính trong interface
		
	
	+ interface mở rộng từ JAVA08 đến hiện tại
		--> có thể chứa 
		. phương thức trừu tượng
		. phương thức bình thường
			private/default/static return_type method_name(..) {
				// body
			}
			. VÌ SAO TỪ JAVA 08 INTERFACE ĐƯỢC CHỨA HÀM BÌNH THƯỜNG
			. Lúc này interface sẽ có chức năng giống với abstract class
			
	--> Interface --> 1 hoặc nhiều hàm trừu tượng
	+ Có 2 cách để override hàm trừu tượng
	1. Tạo class con implement từ interface
		--> override abstract method
	2. New trực tiếp interface --> anonumous class
		--> override abstract method
		
--> Khi Interface mà có 1 hàm trừu tượng  
	--> functional interface @FunctionalInterface
	--> Để tạo đối tượng/thể hiện/giá trị cho biến kiểu Functional Interface
	--> Thay vì dùng cách 1,2 phía trên thì sử dụng anonymous function (lambda expression)
	
	
		
Câu 4. Một KDL con có thể kế thừa từ một hoặc nhiều KDL cha không, vì sao?
	Con: class/interface/abstract class
	Cha: class/interface/abstract class
	
	Khi KDL con là class
	--> chỉ được kế thừa (extends) duy nhất từ 1 CLASS cha
	
			--> Vì nếu như một class con kế thừa từ nhiều class cha
			Trong trường hợp các class cha có chung hàn (khai báo) và các
			phương thức lại không bắt buộc override trong class --> có kế thừa
			dùng mặc định các hàm chung từ class cha 
		--> con gọi phương thức chung đó --> không biết gọi ai
		--> không cho extends từ nhiều class cha
			
	--> Có thể kế thừa (thực thi) (implements) từ nhiều interface cha
	
	KEY:
--> Phương thức trong CLASS cha --> không bắt buộc override trong CLASS con
--> Phương thức trong INTERFACE cha --> bắt buộc override trong CLASS con



--> Nhiều KDL con có thể kế thừa từ 1 KDL cha? --> có thể 
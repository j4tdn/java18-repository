1. Tính chất thừa kế là gì? Cho ví dụ, code minh họa
 --> khi các class muốn dùng trong dự án, có phương thức và thuộc tính trùng nhau
 --> thay vì ở mỗi class lặp đi lặp lại các phương thức và thuộc tính chung đó -> gây trùng lặp code
 --> Giải quyết: tạo class cha chứa các phương thức và thuộc tính chung đó
 --> Sau đó mỗi class con sẽ kế thừa từ cha, muốn mở rộng (extends) hoặc override thì tạo thêm ở class con
 
 VD: 
  + Thừa kế thuộc tính 
    class Book: id, name, publisher
    class ClassicalBook extends Books 
        status
    class ReferenceBook extends Books
    	tax
    
  
  + Thừa kế phương thức (override)
    interface Shape 
        void calS();
    class Rectangle implements Shape {
    	@Override
        public void calS() {
        }
    }
    
    class Father {
    	String getSport() {
    	return "badminton, volleyball";
    	}
    }
    
    class Son extends Father {
    
    }
    
2. KDL Cha có thể là ai? 
 --> class, abstract class, interface
 
3. Phân biệt class, abstract class, interface 
	+ class: chứa thuộc tính và phương thức bình thường
	+ abstract class : chứa thuộc tính và phương thức bình thường & trừu tượng
	--> cha là [abstract] class thì class con chỉ kế thừa duy nhất 1 [abstract] class
	
	+ interface: chứa thuộc tính và phương thức trừu tượng
	. thuộc tính trong interface bắt buộc phải khởi tạo giá trị 
		--> vì không thể override trong lớp con
		--> mặc định là static
		--> hiếm khi tạo biến/thuộc tính trong interface
	
	--> cha là interface thì class con có thể kế thừa từ 1 hoặc nhiều interface
	*** interface mở rộng từ JAVA08 đến hiện tại
		--> có thể chứa 
		. phương thức trừu tượng 
		. phương thức bình thường: không bắt buộc phải override
			private, default, static return_type method_name(..) {
				// body
			}
		. Vì sao từ JAVA08 interface được phép chứa hàm bình thường?
		. Lúc này interface sẽ có chức năng giống với abstract class
		--> sao không dùng abstract class luôn? Lợi ích gì?
		
		--> Interface --> 1/N hàm trừu tượng
			+ có 2 cách để override hàm trừu tượng
			 1. Tạo class con implements từ interface 
			    --> override abstract method
			 2. New trực tiếp interface --> anonymous class 
			    --> override abstract method
		-new-> Khi interface có 1 hàm trừu tượng
			  --> functional interface @FunctionalInterface
			  --> Để tạo đối tượng/thể hiện/giá trị cho biến kiểu functional interface 
			  => thay vì dùng cách 1 và 2 ở trên 
			  => thì sử dụng anonymous function (lambda expression)
	
		
		
		
		. phương thức bình thường: có body
		. phương thức trừu tượng: không có body
	
	--> N KDL con có thể kế thừa từ 1 KDL cha --> DONE	
4. 1 KDL con có thể kế thừa từ một hoặc nhiều KDL cha không, vì sao?
	con: class/abstract class/interface
	cha: class/abstract class/interface
	
	Khi KDL con là CLASS 
	--> chỉ được kế thừa (extends) duy nhất từ 1 CLASS cha 
	↓
	Trả lời:
	Nếu như 1 class con kế thừa từ nhiều class cha 
	Trong trường hợp các class cha có chung hàm (khai báo) và các phương thức lại ko bắt buộc override trong class con
	--> con kế thừa dùng mặc định các hàm chung từ class cha
	--> con gọi phương thức chung đó --> ko biết gọi ai 
	--> error first (bắt lỗi ngày từ đầu) --> ko cho extends từ nhiều class cha 
	
	--> có thể thực thi (implements) từ N interface cha
	↓
	Trả lời:
	
	
	KEY:
	--> Phương thức trong CLASS cha --> không bắt buộc override trong CLASS con
	--> Phương thức trong INTERFACE cha --> bắt buộc override trong CLASS con
	
	
 
 
 
 
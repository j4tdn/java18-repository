1. Tính chất thừa kế là gì cho vd minh họa
	- khi class có chung những thuộc tính/phương thức, 
	  trùng lặp code thì mình có thể tạo ra 1 class cha chung chứa đặc điểm những phương thức 
	  chung dó sau đó class con sẽ kế thừa từ cha muốn extends/override thì tạo thêm ở lớp con.
	  vd - thừa kế thuộc tính
	  		+ class Book: id, name, publisher
	  		+ class ClassicalBook extends Book
	  			status
	  		+ class ReferenceBook extends Book
	  			tax
	  	 - thừa kế phương thức
	  	 	+ interface Shape
	  	 		void calS();
	  	 	  class Rectangle implement Shape {
	  	 	  			@override
	  	 	  			public void calS{
	  	 	  		}
	  	 	  }
	  	 	  
	  	 	  class Father{
	  	 	  	String getSport(){
	  	 	  		return "badminton, volleyball";
	  	 	  		}
	  	 	  }
	  	 	  
	  	 	  class Son extends Farther{
	  	 	  
	  	 	  }
	  	 	  
2. KDL cha có thể là ai
	--> class, abstract class, interface

3. phân biệt class/abstract class/interface
 + class: chứa thuộc tính và phương thức bình thường
 + abstract class: chứa thuộc tính và phương thức bình thường và trừu tượng
 
 --> cha là [abstract] class thì class con chỉ kế thừa duy nhất đc 1[abstract]c lass
 + interface: chứa thuppcj tính và phương thức trừu tượng
   . phương thức bt: có body
   . phương thức trừu tượng: không có body
   . thuộc tính trong interface bắt buộc
   	+ phải khởi tạo giá trị --> vì ko thể override trong lớp con
   	+ mực định là static
   	+ hiếm khi tạo biến/thuộc tính trong interface	
   	
   	--> khi cha là interface thì class con có thể kế thừa từ 1 hoặc nhiều interface
   	+ interface mở rộng từ java08 đến java hiện tại
   		--> có thể chứa
   		 . phương thức trừu tượng
   		 . phương thức bình thường -> ko bắt buộc phải override 
   		 	private/default/static return_type method_name(...){
   		 	// body
   		 	}
   		 . vì sao từ java08 interface đc phép chứa hàm bình thường
   		 . lúc này interface sẽ có chứa năng giống vs abtract class
   		 -> sao ko dùng abstract class luôn? lợi ích j?
   		 -> Interface --> 1/n hàm trừu tượng
   		   + có 2 cách để override hàm trừu tượng
   		   1.tạo class com implement method
   		    --> override abstract method
   		   2. new trực tiếp interface --> anonymous class
   		    -> override abstract method
   		    
   		 new-> khi interface có 1 hàm trừu tượng 
   		      -> functional interface  @functionalInterface
   		      -> đểmtạo đối tượng/thể hiện/giá trị chó biến kiểu functional interface 
   		      -> thay vì dùng cách  1/2 phía trên thì sử dụng anonymous function (lambda expression)
   		 
   	
   	--> N KDL con có thể kế thừa từ 1 KDL cha
4. 1 KDL con có thể kế thừa từ 1/nhiều KDL cha không, vì sao.
	con: class/ interface/ abstract class
	cha: class/ interface/ abstract class
	
	Khi KDL con là class:
	--> chỉ được kế thừa(extends) duy nhất từ 1 class
	--> có thể kế thừa( thực thi) implement từ N interface cha
	
	KEY: 
		- phương thức trong class cha --> không bắt buộc override class con
		- phương thức interface cha --> bắt buộc override trong class 
   	
   	 vì nếu như 1 class con kế thừa từ nhiều class cha 
   	 trong trường hợp các class cha có thể chung hàm khai báo và 
   	 các phương thức lại không bắt buộc override trong class 
   	 --> con kế thừa dùng mặc định các hàm chung từ class cha
   	 
   	 --> con goin phương thức chung đó --> ko bik gọi ai
   	 --> eror first --> ko cho extend từ nhiều class cha
   	 